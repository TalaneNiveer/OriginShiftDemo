# OriginShiftDemo
Python demo of using OriginShift+DFS to generate 100% unique mazes

This demo shows how using the Origin Shift method of moving the root node in a root-connected directional tree, following following a DFS maze generation algorithm instead of random walks guarantees a smooth transition to a completely new random state.

Keyboard controls:
Spacebar advances the algorithm one iteration
'm' key: toggle 10FPS automatic iterations
'q' key: quit

The app displays the trivial maze on the left and then Origin-Shifts the root node along the path that the DFS algorithm uses for drawing a brand new maze from scratch on the right.

The net effect is that the left maze transforms into the right maze with each intermediate step maintaining its integrity as a perfect maze.

This is not optimized. The DFS implementation has to be implemented in a specific way to ensure that it backtracks one space at a time. Most DFS implementations optimize out the backtracking with a stack. The point is, ignore the maze generation algorithm details on the right. the fun stuff is on the left, guided by the right.

The primary optimization needed for CaptainLuma's project is simply to check if the origin-shift was actually a change or not to the maze structure. While the DFS is digging, the changes to the original are visible with each step; however, backtracking does not change the maze structure. Since the Captain wants a visible change on every iteration, you would loop through the iterations until the resulting origin-shift represented a structural change to the path. The DFS is fast enough that it won't impact what you are doing at all.

I do have an optimized DFS that would allow this to work on truly massive mazes, but that muddies the example and was not the goal. Please don't get hung up on the details of the DFS generator.

The other handy thing, algorithmically, is that when the first pass is complete, you can start over because it always starts and ends at the same point. 

All of the code is 100% generated by Claude3. I no longer code. I prompt and debug and prompt again. For curiosity's sake: it took 9 prompts to explain the algorithm and 6 prompts to generate and debug the code presented here. 

